# 区块链

[toc]
- [区块链](#区块链)
  - [1、前言摘要](#1前言摘要)
  - [2、底层的数学依托【核心算法：非对称加密】](#2底层的数学依托核心算法非对称加密)
    - [2.1、对称加密 vs 非对称加密](#21对称加密-vs-非对称加密)
      - [2.1.1、对称加密](#211对称加密)
      - [2.1.2、非对称加密（核心重点）](#212非对称加密核心重点)
        - [2.1.2.1、非对称加密的相关数论基础](#2121非对称加密的相关数论基础)
        - [2.1.2.2、公钥和私钥](#2122公钥和私钥)
        - [2.1.2.3、非对称加密的相关算法](#2123非对称加密的相关算法)
          - [2.1.2.3.1、引入一个基础算法](#21231引入一个基础算法)
          - [2.1.2.3.2、`RSA`算法](#21232rsa算法)
          - [2.1.2.3.3、椭圆加密算法（`ECC`）](#21233椭圆加密算法ecc)
          - [2.1.2.3.4、`Diffie-Hellman`密钥协议算法（简称DH算法）](#21234diffie-hellman密钥协议算法简称dh算法)
          - [2.1.2.3.5、背包加密算法](#21235背包加密算法)
          - [2.1.2.3.6、`ElGamal`加密算法](#21236elgamal加密算法)
          - [2.1.2.3.7、`Rabin`算法](#21237rabin算法)
    - [2.2、对（非对称）算法体系的潜在威胁：量子计算机](#22对非对称算法体系的潜在威胁量子计算机)
    - [2.2、非对称加密算法的实际产品应用之数字签名(亦称：数字签章)](#22非对称加密算法的实际产品应用之数字签名亦称数字签章)
      - [2.2.1、数字签名](#221数字签名)
        - [2.2.1.1、数字签名的工作流程](#2211数字签名的工作流程)
        - [2.2.1.2、CA（certificate authority，简称CA）](#2212cacertificate-authority简称ca)
        - [2.2.1.3、需要涉及到的算法（非对称加密的相关算法 + Hash算法）](#2213需要涉及到的算法非对称加密的相关算法--hash算法)
          - [2.2.1.3.1、Hash算法（亦称：散列算法、摘要算法）](#22131hash算法亦称散列算法摘要算法)
      - [2.2.2、数字签名的产品应用](#222数字签名的产品应用)
        - [2.2.2.1、`SSL`：从`http`到`https` = `对称加密`  + `非对称加密 `](#2221ssl从http到https--对称加密---非对称加密-)
        - [2.2.2.2、`Apple`校验机制](#2222apple校验机制)
          - [2.2.2.2.1、双重签名流程](#22221双重签名流程)
          - [2.2.2.2.2、CSR文件](#22222csr文件)
          - [2.2.2.2.3、从Member Center中申请开发证书](#22223从member-center中申请开发证书)
          - [2.2.2.2.4、 iOS授权和描述文件](#22224-ios授权和描述文件)
        - [2.2.2.3、区块链](#2223区块链)

## 1、前言摘要

*资料来源*

[CSDN/公钥/私钥/数字签名/数字证书及 RSA加解密数学原理](https://blog.csdn.net/wteruiycbqqvwt/article/details/106121134)

[稀土掘金/关于公钥与私钥的理解](https://juejin.cn/post/6978872809388769287)

[博客园/公钥与私钥](https://www.cnblogs.com/igoodful/p/9646095.html)

[RSA 算法介绍与演示](https://www.quchao.net/RSA.html)

[知乎/理解公钥和私钥](https://zhuanlan.zhihu.com/p/113522792)

[阿里云/什么是公钥和私钥？](https://help.aliyun.com/document_detail/42216.html)

[理解公钥与私钥](https://songlee24.github.io/2015/05/03/public-key-and-private-key/)

[华为云/公钥、私钥、数字证书的关系是什么？](https://support.huaweicloud.com/intl/zh-cn/ccm_faq/ccm_01_0122.html)

[知乎/密码学浅谈（1）：非对称加密与 RSA 算法](https://zhuanlan.zhihu.com/p/543705396)

[小菜学编程/非对称加密算法简介及编程实践](https://fasionchan.com/network/cryptography/asymmetric-encryption/)

[稀土掘金/RSA 数学原理](https://juejin.cn/post/6844903729397760013)

[腾讯云/开发者社区/公钥可以解密吗?](https://cloud.tencent.com/developer/article/1415048)

```
1、以太坊是交易所平台，交易所平台可以有多个链;
2、ETH、BTC、USDT 这些是加密数字货币，币依托于链而存在;
3、交易所平台的存在允许不同币之间的兑换;
4、通过链和 ID 可以找到这个 ID 历史相关的所有交易记录，但是因为不是实名制，所以你并不知道参与者是谁，只会知道存在这笔交易;
5、共识原则:满足51%的节点承认你这笔交易，即成功！如果当时的你这个节点离线，那么上线的时候会进行同步历史区块数据;
6、每一个加密货币的共识机制都可能不一样，但是最底层的数学逻辑都是一致的。关键词：质数、密码学、非对称加密（公钥私钥）、非对称加密有很多算法，常用椭圆函数，等...
7、目前 tron 是唯一的能开商户的合约平台，商户内互转不要手续费，但是上公链就需要;
8、汇旺用的就是 tron ，但是汇旺可能有多个商户;
9、在欧洲区块链合法化受到法律监管，有些 USDT 来路不正，称之为"黑U"，市面上有人收黑U的;
10、最关键的是助记词和私钥，可以转化为离线的死数据文本文件进行存储，俗称冷钱包。汇旺没有私钥和助记词，有一定风险，但是他盘子做的大，中间层有人维护，对不专业人士来讲友好，但是对专业人士来讲不可靠。市面上对冷钱包有开发出来类似U盘一样的东西对其进行存储;
11、各种币到最后都是越用越少的，因为有一部分人会忘记私钥和助记词;
12、加密分对称加密和非对称加密;
		12.1、对称效率高安全性低，非对称安全性高效率低。这里的效率主要体现在算力，能耗，耗时。
		12.2、区块链主打去中心化，但是汇旺这种就是中心化，归集为一个点再去中心，那么汇旺本身就是中心化的产品，效率高但是不公平（随时可以封你），
		12.3、所以效率和安全永远是辩证关系;
13、私钥能推出公钥，公钥无法反推私钥;
14、公钥和私钥通常有可以互相加解密的特性:
	  14.1、将原始信息用公钥加密后，可以使用私钥解密;
	  14.2、将原始信息用私钥加密后，通常可以使用公钥解密;(比如CA数字证书)
15、区块链类似于数据库，只不过准备写入的数据通过验证进行写入以后，数据不能进行修改;
16、区块链上不仅仅可以存文字，同样可以存视频图像语音等二进制数据;
```

## 2、底层的数学依托

### 2.1、对称加密 vs 非对称加密「核心算法」

#### 2.1.1、对称加密

```
简而言之:用同一把钥匙加密和解密
优势:传统、性能高效、低耗能
劣势:不安全

常用算法:DES、3DES、AES
```

#### 2.1.2、「核心算法」非对称加密

*资料来源*

[维基百科/哥德巴赫猜想](https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3)

[维基百科/后量子密码学](https://zh.wikipedia.org/wiki/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81%E5%AD%A6)

[百度百科/哥德巴赫猜想](https://baike.baidu.com/item/%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3/72364)

[陈景润研究的“1+1”是什么，他又是如何证明“1+2”的](https://www.sohu.com/a/470304343_121116754)

[CSDN/ssh用私钥生成公钥](https://blog.csdn.net/lxfHaHaHa/article/details/86619714)

[知乎/图文彻底搞懂非对称加密（公钥密钥）](https://zhuanlan.zhihu.com/p/436455172)

##### 2.1.2.1、非对称加密的相关数论基础

```
1、RSA算法的原理是基于这样的数学事实：两个大质数相乘得到的大数难以被因式分解。即一个大数很难被因式分解;
2、虽然现在有大量的数据事实作为依据，但是底层尚未完全证明，而非定理，所以目前仅仅是猜想;
3、哥德巴赫猜想（尚未证明）:任一大于2的偶数，都可表示成两个素数之和;

针对哥德巴赫猜想相关著名的数论研究发展历史:
1966年陈景润证明了"1+2"成立。即，任一充分大的偶数都可以表示成二个素数的和，或是一个素数和一个半素数的和。
```

```
研究偶数的哥德巴赫猜想的四个途径:
1、殆素数:
殆素数就是素因子个数不多的正整数。现设 N 是偶数，虽然不能证明N是两个素数之和，但足以证明它能够写成两个殆素数的和，即: N=A+B，其中 A 和 B 的素因子个数都不太多，譬如说素因子个数不超过10。用"a+b"来表示如下命题：每个大偶数 N 都可表为 A+B，其中A和B的素因子个数分别不超过a和b。显然，哥德巴赫猜想就可以写成"1+1"。在这一方向上的进展都是用所谓的筛法得到的。
"a + b"问题的推进
1920年，挪威的布朗证明了"9 + 9"。
1924年，德国的拉特马赫证明了"7 + 7"。
1932年，英国的埃斯特曼证明了"6 + 6"。
1937年，意大利的蕾西先后证明了"5 + 7", "4 + 9", "3 + 15" 和 "2 + 366"。
1938年，苏联的布赫夕太勃证明了"5 + 5"。
1940年，苏联的布赫夕太勃证明了"4 + 4"。
1956年，中国的王元证明了"3 + 4"。稍后证明了"3 + 3"和"2 + 3"。
1948年，匈牙利的瑞尼证明了"1 + c"，其中 c 是一很大的自然数。
1962年，中国的潘承洞和苏联的巴尔巴恩证明了"1 + 5"， 中国的王元证明了"1 + 4"。
1965年，苏联的布赫夕太勃和小维诺格拉多夫，及意大利的朋比利证明了"1 + 3"。
1966年，中国的陈景润证明了"1 + 2" 。

2、例外集合:
在数轴上取定大整数 x，再从x往前看，寻找使得哥德巴赫猜想不成立的那些偶数，即例外偶数。x之前所有例外偶数的个数记为 E(x)。我们希望，无论 x 多大，x 之前只有一个例外偶数，那就是2，即只有2使得猜想是错的。这样一来，哥德巴赫猜想就等价于 E(x) 永远等于1。当然，还不能证明 E(x) = 1；但是能够证明 E(x) 远比 x 小。在 x 前面的偶数个数大概是 x/2;如果当x趋于无穷大时，E(x) 与 x 的比值趋于零，那就说明这些例外偶数密度是零，即哥德巴赫猜想对于几乎所有的偶数成立。这就是例外集合的思路。
维诺格拉多夫的三素数定理发表于1937年。第二年，在例外集合这一途径上，就同时出现了四个证明，其中包括华罗庚先生的著名定理。
业余搞哥德巴赫猜想的人中不乏有人声称"证明"了哥德巴赫猜想在概率意义下是对的。实际上他们就是“证明”了例外偶数是零密度。这个结论华罗庚早在60年前就已真正证明出来。

3、小变量的三素数定理:
我们可以把这个问题反过来思:如果偶数的哥德巴赫猜想正确，那么奇数的猜想也正确。已知奇数 N 可以表成三个素数之和，假如又能证明这三个素数中有一个非常小，譬如说第一个素数可以总取3，那么我们也就证明了偶数的哥德巴赫猜想。这个思想促使潘承洞先生在1959年，25岁时，研究有一个小素变数的三素数定理。这个小素变数不超过 N 的 θ 次方。我们的目标是要证明 θ 可以取0，即这个小素变数有界，从而推出偶数的哥德巴赫猜想。潘承洞先生首先证明 θ 可取1/4。后来的很长一段时间内，这方面的工作一直没有进展，直到1995年展涛教授把潘老师的定理推进到7/120。这个数已经比较小了，但是仍然大于0。

4、哥德巴赫问题:
1953年，林尼克发表了一篇长达70页的论文。在文中，他率先研究了几乎哥德巴赫问题，证明了，存在一个固定的非负整数 k ，使得任何大偶数都能写成两个素数与 k 个2的方幂之和。这个定理，看起来好像丑化了哥德巴赫猜想，实际上它是非常深刻的。我们注意，能写成 k 个2的方幂之和的整数构成一个非常稀疏的集合；事实上，对任意取定的x，x前面这种整数的个数不会超过 log x 的 k 次方。因此，林尼克定理指出，虽然我们还不能证明哥德巴赫猜想，但是我们能在整数集合中找到一个非常稀疏的子集，每次从这个稀疏子集里面拿一个元素贴到这两个素数的表达式中去，这个表达式就成立。这里的 k 用来衡量几乎哥德巴赫问题向哥德巴赫猜想逼近的程度，数值较小的k表示更好的逼近度。显然，如果 k 等于0，几乎哥德巴赫问题中2的方幂就不再出现，从而，林尼克的定理就是哥德巴赫猜想。
林尼克1953年的论文并没有具体定出k的可容许数值，此后四十多年间，人们还是不知道一个多大的k才能使林尼克定理成立。但是按照林尼克的论证，这个 k 应该很大。1999年，作者与廖明哲及王天泽两位教授合作，首次定出k的可容许值54000。这第一个可容许值后来被不断改进。其中有两个结果必须提到，即李红泽、王天泽独立地得到 k = 2000。最好的结果 k = 13 是英国数学家希思-布朗(D. R. Heath-Brown)和德国数学家普赫塔(Puchta)合作取得的，这是一个很大的突破。
```

##### 2.1.2.2、公钥和私钥

```
简而言之:用不同的钥匙进行加密和解密

优势:目前软硬件条件下的相对安全（在以目前2进制为基础的计算机构架上，很难去进行破解。除非量子计算机技术进行有效的突破。但是量子计算机目前尚又处于研发阶段，暂不能适用于商用，为了保证量子态也需要极高的物理环境，比如极低温，所以去进行正向暴力破解是一件高耗时耗能的操作）

劣势:高耗能、高耗时

特点:
1、通过私钥生成公钥，但是公钥不能生成私钥;类似于发光二极管，正向电阻极小，逆向电阻极大。
2、公钥私钥总是成对出现;
3、公钥和私钥通常有可以互相加解密的特性：
	3.1、将原始信息用公钥加密后，可以使用私钥解密；
  3.2、将原始信息用私钥加密后，通常可以使用公钥解密。

数学依据:质数
质数是指只能被1和自身整除的正整数，也称为素数。
质数在数学中有着重要的地位，因为它们是构成其他整数的基本元素，任何一个正整数都可以唯一地分解成若干个质数的乘积。质数在密码学中也有着广泛的应用，例如: RSA 加密算法就是基于质数的乘积分解难题而设计的。

公钥密码体制根据其所依据的难题一般分为三类：
1、大素数分解问题类、
2、离散对数问题类、
3、椭圆曲线类。有时也把椭圆曲线类归为离散对数类。

非对称加密算法是一类型加密算法的统称，主要算法：RAS（使用最广泛）、Elgamal（比较常用）、背包算法、Rabin、D-H、Ecc。
```

##### 2.1.2.3、非对称加密的相关算法

###### 2.1.2.3.1、引入一个基础算法

```
看一个小时候经常在《趣味数学》这类书里的一个数学小魔术：

让对方任意想一个3位数，
并把这个数和91相乘，
然后告诉我积的最后三位数，
我就可以猜出对方想的是什么数字啦！

比如：
对方想的是123，那么对方就计算出123 * 91等于11193，并把结果的末三位193告诉我。

看起来，这么做似乎损失了不少信息，让我没法反推出原来的数。不过，我仍然有办法：只需要把对方告诉我的结果再乘以11，乘积的末三位就是对方刚开始想的数了。

可以验证一下，193 * 11 = 2123，末三位正是对方所想的秘密数字！

其实道理很简单，91乘以11等于1001，而任何一个三位数乘以1001后，末三位显然都不变（例如123乘以1001就等于123123）。

知道原理后，我们可以构造一个定义域和值域更大的加密解密系统：
比方说，任意一个数乘以400000001后，末8位都不变，而400000001 = 19801 * 20201，于是你来乘以19801，我来乘以20201，又一个加密解密不对称的系统就构造好了。甚至可以构造得更大一些：4000000000000000000000000000001 = 1199481995446957 * 3334772856269093，这样我们就成功构造了一个30位的加密系统。

这是一件非常酷的事情，任何人都可以按照我公布的方法加密一个数，但是只有我才知道怎么把所得的密文变回去。其安全性就建立在算乘积非常容易，但是要把4000000000000000000000000000001分解成后面两个数相乘，在没有计算机的时代几乎不可能成功！但如果仅仅按照上面的思路，如果对方知道原理，知道我要构造出带很多0的数，根据19801和8位算法这2个条件非常容易穷举出400000001这个目标值。要解决这个问题，真实世界就不是使用乘法了，比如RSA算法使用的是指数和取模运算，但本质上就是上面这套思想。
```

###### 2.1.2.3.2、`RSA`算法

```
假设有两个人，Alice 和 Bob，他们想要进行加密通信。他们可以使用非对称加密算法来保护他们的通信内容。
首先，Alice 需要生成一对公钥和私钥。她可以使用 RSA 算法来生成这对密钥。RSA 算法是一种非对称加密算法，它基于两个大质数的乘积难以分解的数学原理。
 Alice 生成公钥和私钥的过程如下：
随机选择两个大质数 p 和 q 。
计算它们的乘积 n = p * q。
计算欧拉函数 φ(n) = (p-1) * (q-1)。
随机选择一个整数 e，使得 1 < e < φ(n)，且 e 与 φ(n) 互质。
计算e关于φ(n)的模反元素d，即满足ed ≡ 1 (mod φ(n))的整数d。
公钥为(n, e)，私钥为(n, d)。
现在，Alice 已经生成了公钥和私钥。她将公钥发送给 Bob ，以便 Bob 可以使用它来加密他的消息。
Bob 想要向Alice发送一条消息m。他可以使用 Alice 的公钥来加密这条消息。加密的过程如下：
将消息 m 转换为一个整数 M。
计算 C ≡ M^e (mod n)。
C 就是加密后的密文。
Bob 将密文C发送给 Alice。 Alice 可以使用她的私钥来解密这个密文。
解密的过程如下:
计算 M ≡ C^d (mod n)。
M 就是解密后的明文。
将 M 转换回原始的消息 m。
这样，Alice 和 Bob 就可以安全地进行加密通信了。由于只有 Alice 拥有私钥，所以只有她能够解密 Bob 发送的消息。这就保证了通信的机密性。
```

###### 2.1.2.3.3、`ECC`椭圆加密算法

*资料来源*

[维基百科/椭圆函数](https://zh.wikipedia.org/wiki/%E6%A9%A2%E5%9C%93%E5%87%BD%E6%95%B8)

[百度百科/椭圆函数](https://baike.baidu.com/item/%E6%A4%AD%E5%9C%86%E5%87%BD%E6%95%B0/7529829)

```
椭圆加密算法（ECC）是一种公钥加密体制，最初由 Koblitz 和 Miller 两人于1985年提出。
其数学基础是利用椭圆曲线上的有理点构成Abel加法群上椭圆离散对数的计算困难性。
```

*优势*

```
1、安全性高:有研究表示160位的椭圆密钥与1024位的RSA密钥安全性相同
2、处理速度快:
	2.1、在私钥的加密解密速度上，ecc算法比RSA、DSA速度更快;
	2.2、存储空间占用小;
	2.3、带宽要求低;
```

*`ECC`与`RSA`对比*

```
1、RSA 算法的特点之一是数学原理简单、在工程应用中比较易于实现，但它的单位安全强度相对较低。
用国际上公认的对于 RSA 算法最有效的攻击方法--一般数域筛 (NFS) 方法去破译和攻击RSA算法，它的破译或求解难度是亚指数级的;
2、ECC 算法的数学理论非常深奥和复杂，在工程应用中比较难于实现，但它的单位安全强度相对较高。
用国际上公认的对于ECC算法最有效的攻击方法--Pollard rho方法去破译和攻击ECC算法，它的破译或求解难度基本上是指数级的。

也就是说，要达到同样的安全强度，ECC 算法所需的密钥长度远比RSA算法低。
这就有效地解决了为了提高安全强度必须增加密钥长度所带来的工程实现难度的问题。
```

###### 2.1.2.3.4、`Diffie-Hellman`密钥协议算法（简称DH算法）

*资料来源*

[百度百科/Diffie-Hellman密钥协议算法](https://baike.baidu.com/item/Diffie-Hellman%E5%AF%86%E9%92%A5%E5%8D%8F%E8%AE%AE%E7%AE%97%E6%B3%95/20837131)

[廖雪峰的官方网站/密钥交换算法](https://www.liaoxuefeng.com/wiki/1252599548343744/1304227905273889)

```
1、一种确保共享密钥 KEY 安全穿越不安全网络的方法；
2、它是 OAKLEY 的一个组成部分；
3、由 Whitefield 与 Martin Hellman 在1976年提出;

简而言之：可以如下定义离散对数：首先定义一个素数p的原根，为其各次幂产生从1 到 p-1 的所有整数根，也就是说，如果 a 是素数 p 的一个原根，那么数值 a mod p,a2 mod p,...,ap-1 mod p 是各不相同的整数，并且以某种排列方式组成了从1到 p-1 的所有整数。对于一个整数 b 和素数 p 的一个原根 a ，可以找到惟一的指数 i，使得 b = a^i mod p 其中0 ≤ i ≤ (p-1)指数i称为b的以a为基数的模p的离散对数或者指数。

基于原根的定义及性质，可以定义Diffie-Hellman密钥交换算法。该算法描述如下:
1、有两个全局公开的参数，一个素数q和一个整数a，a是q的一个原根;
2、假设用户A和B希望交换一个密钥，用户A选择一个作为私有密钥的随机数 XA(XA<q)，并计算公开密钥 YA = a^XA mod q。A对XA的值保密存放而使YA能被B公开获得。类似地，用户B选择一个私有的随机数XB<q，并计算公开密钥YB=a^XB mod q。B对XB的值保密存放而使YB能被A公开获得;
3、用户A产生共享秘密密钥的计算方式是K = (YB)^XA mod q.同样，用户B产生共享秘密密钥的计算是K = (YA)^XB mod q。这两个计算产生相同的结果： K = (YB)^XA mod q = (a^XB mod q)^XA mod q = (a^XB)^XA mod q （根据取模运算规则得到） = a^(XBXA) mod q = (a^XA)^XB mod q = (a^XA mod q)^XB mod q = (YA)^XB mod q 因此相当于双方已经交换了一个相同的秘密密钥;
4，因为XA和XB是保密的，一个敌对方可以利用的参数只有 q , a , YA 和 YB 。因而敌对方被迫取离散对数来确定密钥。例如，要获取用户B的秘密密钥，敌对方必须先计算 XB = inda , q(YB) 然后再使用用户B采用的同样方法计算其秘密密钥K。Diffie-Hellman 密钥交换算法的安全性依赖于这样一个事实:虽然计算以一个素数为模的指数相对容易，但计算离散对数却很困难。对于大的素数，计算出离散对数几乎是不可能的;
下面给出例子：密钥交换基于素数 q = 97 和 97 的一个原根 a = 5。A 和 B 分别选择私有密钥 XA = 36 和 XB = 58。每人计算其公开密钥 YA = 5^36 = 50 mod 97 YB = 5^58 = 44 mod 97 在他们相互获取了公开密钥之后，各自通过计算得到双方共享的秘密密钥如下:K = (YB)^XA mod 97 = 44^36 = 75 mod 97 K = (YA)^XB mod 97 = 50^58 = 75 mod 97 从|50,44|出发，攻击者要计算出75很不容易。

优势:
1、仅当需要时才生成密钥，减小了将密钥存储很长一段时间而致使遭受攻击的机会;
2、除对全局参数的约定外，密钥交换不需要事先存在的基础结构;

劣势:
1、没有提供双方身份的任何信息;
2、它是计算密集性的，因此容易遭受阻塞性攻击，即对手请求大量的密钥。受攻击者花费了相对多的计算资源来求解无用的幂系数而不是在做真正的工作;
3、没办法防止重演攻击;
4、容易遭受中间人的攻击：
	第三方 C 在和 A 通信时扮演 B ;和 B 通信时扮演 A 。A 和 B 都与 C 协商了一个密钥，然后 C 就可以监听和传递通信量。中间人的攻击按如下进行：
	4.1、B 在给 A 的报文中发送他的公开密钥;
	4.2、C 截获并解析该报文。C将B的公开密钥保存下来并给A发送报文，该报文具有 B 的用户 ID 但使用 C 的公开密钥 YC，仍按照好像是来自B的样子被发送出去。A 收到 C 的报文后，将 YC 和 B 的用户 ID 存储在一块。类似地，C 使用 YC 向 B 发送好像来自 A 的报文;
	4.3、B 基于私有密钥 XB 和 YC 计算秘密密钥 K1。A 基于私有密钥 XA 和 YC 计算秘密密钥 K2。C 使用私有密钥 XC 和 YB 计算 K1，并使用 XC 和 YA 计算 K2;
	4.4、从现在开始，C 就可以转发 A 发给 B 的报文或转发 B 发给 A 的报文，在途中根据需要修改它们的密文。使得A和B都不知道他们在和C共享通信。
```

###### 2.1.2.3.5、背包加密算法

```
由 Ralph Merkle 和 Martin Hellman 在1978年提出

背包加密算法的基本思想是利用背包问题中的0/1背包问题，将明文转换为一个01序列，然后使用一个特殊的背包作为私钥，将01序列加密成一个大整数，再使用一个公钥对其进行解密。

背包加密算法的加密过程如下:
选择一个超递增背包作为私钥，即满足 w1 < w2 < … < wn，且对于任意的 i，都有 wi = w1 + w2 + … + wi-1。
将明文转换为一个01序列，即将明文中的每个字符转换为其对应的二进制数，并将二进制数的每一位作为01序列的一个元素。
将01序列与超递增背包进行加密，即将01序列中的每个元素与超递增背包中的每个元素相乘，然后将它们的和作为密文。

背包加密算法的解密过程如下:
使用私钥中的逆元素计算出一个新的背包，即将私钥中的每个元素乘以其逆元素。
将密文进行解密，即将密文与新的背包进行点积运算，得到一个01序列。
将01序列转换为明文，即将01序列中的每8个元素组成一个字节，然后将字节转换为对应的字符。

背包加密算法的安全性基于超递增背包的困难性问题，即在已知超递增背包的情况下，求解其逆元素的问题是一个NP完全问题。
```

###### 2.1.2.3.6、`ElGamal`加密算法

*资料来源*

[维基百科/ElGamal加密算法](https://zh.wikipedia.org/wiki/ElGamal%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95)

###### 2.1.2.3.7、`Rabin`算法

*资料来源*

[RSA衍生算法—RABIN算法](https://co5mos.github.io/2018/09/14/rsa-rabin/)

[CSDN/Rabin加密算法](https://blog.csdn.net/qq_43698421/article/details/107452334)

[简书/RSA 衍生算法——Rabin 算法](https://www.jianshu.com/p/c18ee34058ed)

[夏冰软件/简述Rabin加密算法](https://www.jiamisoft.com/blog/28727-rabin.html)

##### 2.1.2.4、对（非对称）算法体系的潜在威胁：量子计算机

*资料来源*

[百度百科/量子计算](https://baike.baidu.com/item/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/11035661)

[一种量子计算机](https://patents.google.com/patent/CN106529681A/zh)

[维基百科/量子计算机](https://zh.wikipedia.org/zh-my/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA)

[百度百科/量子计算机](https://baike.baidu.com/item/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA/363335#3_1)

[微软官网/量子计算中的量子比特](https://learn.microsoft.com/zh-cn/azure/quantum/concepts-the-qubit)

**量子计算机和普通计算机**

```
普通计算机处理数据，是将一切数据翻译成2进制进行输入处理。2进制即每一位由0和1进行表达。
例如：32位电脑，他的 CPU 的数据宽度为32位，也就是它一次最多可以处理32位数据，即：由0或者1组成的一个基础命令或者数据;
其内存寻址空间在2^32 = 4294967296Byte = 4G左右。(大于4G内存，无法识别，即便能识别，高位地址永远无法用到);
因为，内存地址越多，所需要的电压越高。在设计主板之初或者在操作系统的驱动层面，对电压进行了核定，也就是超过标准的内存，可能出现无法识别、不稳定等兼容性问题。所以，32位电脑只能安装32位系统，不能安装64位的操作系统
64位电脑，由此顺理推演。
所以，64位计算机的数据处理能力＞32位计算机的数据处理能力
但不管如何，一个数据位仅有2种状态表示，即：0或者1

因为量子计算机的芯片架构，量子比特存在多个量子位。
所以，量子计算机的算力＞＞普通计算机

非对称加密在普通计算机的层面上，正向破解非对称加密，会消耗大量时间，导致即便正确求解以后，也毫无意义。但是在量子计算机层面，因为超高算力，会打破非对称加密的平衡
```

### 2.2、「核心算法」Hash哈希算法（亦称：散列算法、摘要算法）

*资料来源*

[华为云/什么是Hash哈希算法](https://www.huaweicloud.com/zhishi/bcs9.html)

[廖雪峰的官方网站/Hash哈希算法](https://www.liaoxuefeng.com/wiki/1252599548343744/1304227729113121)

[MBA智库百科/Hash哈希算法](https://wiki.mbalib.com/wiki/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95)

[CSDN/什么是hash？什么是Hash哈希碰撞？怎么处理Hash哈希碰撞？](https://blog.csdn.net/YOUYOU0710/article/details/108761052)

[阮一峰的网络日志/Hash哈希碰撞与生日攻击](https://www.ruanyifeng.com/blog/2018/09/hash-collision-and-birthday-attack.html)

[百度百科/彩虹表](https://baike.baidu.com/item/%E5%BD%A9%E8%99%B9%E8%A1%A8/689313)

[简书/安全防护 — Hash算法与碰撞](https://www.jianshu.com/p/9e9832006108)

[简书/iOS逆向一：数字签名&苹果应用双重签名原理&应用重签名](https://www.jianshu.com/p/120abb45dfea)

[百度百科/SHA家族-密码散列函数家族](https://baike.baidu.com/item/SHA%E5%AE%B6%E6%97%8F/9849595)

*Hash哈希简介*

```
Hash哈希算法的作用：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。
Hash哈希算法的目的：为了验证原始数据是否被篡改。
Hash哈希算法是一类型加密算法的统称，主要算法：MD4、MD5和SHA

Hash哈希算法最重要的特点就是:
1、单向性:不可反推;
    Hash哈希函数必须是不可逆的，所以不存在从散列值到原始输入的破解（这里不包括暴力破解，使用彩虹表是暴力破解的最佳方式，但是仍然无法保证破解到的数据是原始数据）。注：彩虹表是一个用于加密散列函数逆运算的预先计算好的表, 为破解密码的散列值（或称哈希值、微缩图、摘要、指纹、哈希密文）而准备。
2、抗篡改:一个小改动会引起哈希指纹的大面积波动;
3、抗碰撞:
    3.1、相同的输入一定得到相同的输出;
    3.2、不同的输入大概率（因为存在Hash哈希碰撞）得到不同的输出; 
 
Hash哈希算法的应用：
1、用户密码的加密
2、搜索引擎
3、版权/云盘秒传功能
4、数字签名
```

```
Hash哈希算法的危机:Hash哈希碰撞
如果不同的输入得到了同一个哈希值，就发生了"Hash哈希碰撞"
```

```
如何防止Hash哈希碰撞:扩大哈希值的取值空间

16个二进制位的Hash哈希值，产生碰撞的可能性是 65536 分之一，
也就是说，如果有65537个用户，就一定会产生碰撞，
哈希值的长度扩大到32个二进制位，碰撞的可能性就会下降到 4,294,967,296 分之一。

更长的哈希值意味着更大的存储空间、更多的计算，将影响性能和成本。
开发者必须做出抉择，在安全与成本之间找到平衡。
```

```
由美国国家安全局（NSA）所设计，并由美国国家标准与技术研究院（NIST）发布；是美国的政府标准。

SHA家族的五个算法，分别是：
1、SHA-1:
在许多安全协定中广为使用，包括 TLS 和SSL、PGP、SSH、S/MIME和IPsec
曾被视为是MD5（更早之前被广为使用的杂凑函数）的后继者
但SHA-1的安全性如今被密码学家严重质疑

以下四者有时并称为 SHA-2:
虽然至今尚未出现对 SHA-2 有效的攻击，它的算法跟 SHA-1 基本上仍然相似;
因此有些人开始发展其他替代的杂凑算法。
2、SHA-224;
3、SHA-256;
4、SHA-384;
5、SHA-512;
```

### 2.3、相关中间件的应用之数字签名(亦称：数字签章)

*资料来源*

[维基百科/数字签名](https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0)

[百度百科/数字签名](https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/212550)

[阮一峰的网络日志/数字签名是什么？](https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)

[稀土掘金/iOS签名校验那些事儿](https://juejin.cn/post/7019129808961404936)

[比特币新一代多签名方案MuSig2：提供更好的安全性、效率和隐私功能](https://www.panewslab.com/zh/articledetails/23q3l9fc.html)

[雪球/为什么黎曼定理会与我们的钱包有关系——初识金融安全体系](https://xueqiu.com/8476758876/114728701)

[runoob/HTTP 与 HTTPS 的区别](https://www.runoob.com/w3cnote/http-vs-https.html)

#### 2.3.1、数字签名的工作流程

```
需要涉及到的算法（非对称加密的相关算法 + Hash哈希算法）

定义信息的发送方为 A
定义信息的接收方为 B
定义需要发送和接受的信息为 M
定义 B 的公钥为 BK
定义 B 的私钥为 bk

生成文件"指纹"的Hash哈希函数是公开的
B 的公钥 BK 亦是公开的

1、A 对信息进行 Hash哈希运算得出一个"指纹"，即：Hash（M）;
2、用 B 的公钥对信息和"指纹"进行打包加密，即:BK（Hash（M）+ M）;
3、A 发送加密讯息：BK（Hash（M）+ M）到 B;
4、B 拿到加密讯息：BK（Hash（M）+ M）以后，用 B 的私钥 bk 进行解密，得出讯息 M 和 M 对应的"指纹"Hash（M），即：bk（BK（Hash（M）+ M））= Hash（M） + M;
5、我们的目的是，验证此时的M是否被篡改。那么用公开的Hash哈希函数对此时接收到的M进行运算，以核对"指纹"是否一致。如果一致，则校验通过。

数字签名的作用:
不可抵赖:如果公钥能解密，则内容一定是与该公钥对应的私钥加密而来，即可证明来源。
数据完整性:数字签名的HASH值和自己计算出的HASH值一致，即可证明该内容是完整的未经修改过。
```

**但是数字签名不能确保"公钥"的真实性，第三方可偷换"公钥"，达到与伪服务器通信的目的，这样又产生了数字证书。**

#### 2.3.2、CA（certificate authority，简称CA）

**所有的信任感的发起源头就是CA中心**

```
由权威证书中心 CA（certificate authority，简称 CA）颁发，作用是证明"公钥"的真实信。
数字证书里面包含了服务器的公钥，服务器的域名以及服务器所属的公司信息等内容，并且该信息是用CA的私钥进行加密的。客户请求服务时，服务器会同时发送数字签名和数字证书给客户。

证书工作流程如下:
服务器向 CA 中心申请证书，CA 负责核实服务器的真实性，并在证书里内置服务器域名证书使用者信息;
客户浏览器或操作系统里内置有权威 CA 的公钥信息（即 CA 公钥不需要在网络中传输）;
客户请求服务时，服务器把自己申请的数字证书和内容的数字签名一同发给客户;
客户收到信息后在本地 CA 列表里查找 CA 公钥对数字证书解密，拿到真正的签名公钥，再用该公钥去解密数字签名，拿到 Hash哈希值去对比完整性;

漏洞：
CA 的公钥是存储在本地计算机列表的，如果手动往列表里面导入了不可信的 CA 公钥，那么 CA 就可以仿冒，失去了权威性。
```

## 3、相关概念落地

### 3.1、在一般的程序开发中的做法

```
1、一般情况下，前端存放公钥，服务端存放私钥。私钥是不允许存放在前端程序;
2、但是，涉及到具体的业务，可能会涉及到很多组（公钥/私钥），又因为（公钥/私钥）是成对出现的，故可以将每一对（公钥/私钥）映射为一个ID，然后专门建立一张密钥表来进行存放;
3、出于安全方面的考虑，服务端对前端传过来的数据是采取保守的不信任态度，也就是前端存储公钥这种做法虽然可行但是欠缺考虑。那么，前端储存业务的（公钥/私钥）ID，服务端可以根据传过来的 ID，后端去遍历对应的私钥表，从而进行解密;
```

### 3.2、`SSL`：从`http`到`https` = `对称加密`  + `非对称加密 `

**原因：非对称加密在解密过程中，消耗的时间远远超过对称加密**

```
在非对称加密在第一阶段通讯的时候，传递适用于第二阶段过程的对称加密的密钥。即:非对称加密（对称加密）;
而在最终的实际数据传输中，用对称加密进行加密通讯
```

###  3.3、`Apple`校验机制

```
对可执行文件或脚本进行数字签名，用来保证软件在签名后未被损害或者修改的措施;
确定 APP 来源并防止外部攻击，确定安装的 APP 有绝对的控制权，以实现苹果对其生态的控制（每年$99、$299这笔开发账号费用）
我们的 iPhone 中和苹果服务器中存在着一对RSA秘钥（iPhone 中存公钥 public key,苹果服务器中存私钥 private key ）

我们从苹果MC（Member Center）中获得的证书实际也是一个包含有证书链的证书，其中的根是苹果的 CA。我们获得的证书实际上是在告诉 iOS 设备:我们的证书是被苹果CA签过名的合法的证书。而 iOS 设备在执行 APP 前，首先要先验证 CA 的签名是否合法，然后再通过证书中我们的公钥验证程序是否的确是我们发布的，且中途没有对程序进行过篡改。
```

#### 3.3.1、双重签名流程

```
1、把 Mac 电脑中的公钥 M(M:代表Mac) 包装成 CSR 文件在 Member Center 中向苹果请求证书;
2、苹果服务器把 CSR 中的公钥M取出来跟 Member Center 中的开发者账号信息一起打包并使用苹果服务器的私钥A(A:代表Apple )进行签名打包成证书;
3、把证书包装成描述文件并使用私钥 A 签名;
4、在开发时，编译完一个 APP 后，用本地的私钥 M(今后你导出的P12) 对这个 APP 进行签名，同时把第三步得到的证书一起打包进 APP 里，安装到手机上;
5、在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证证书的数字签名是否正确;
6、验证证书后确保了公钥M 是苹果认证过的，再用公钥 M 去验证 APP 的签名，这里就间接验证了这个 APP 安装行为是否经过苹果官方允许;
```

#### 3.3.2、`CSR` 文件

```
CSR 文件（CertificateSigningRequest.certSigningRequest）这个文件是我们从钥匙串申请来的为后面申请证书准备的,在 Member Center 中提交该文件向苹果申请证书，这个文件主要包括以下内容:
1、申请者的信息，使用私钥 M 加密;
2、申请者的公钥 M，申请者使用的私钥M对应的公钥 M;
3、摘要算法(Hash哈希算法)，RSA 算法;

苹果的 Member Center 在拿到这个 CSR 文件后，将这个信息记录下来，并签发出相关的证书
这里，苹果实际无需验证我的信息，因为如果我不交钱就没办法上传这个文件，也就得不到证书
```

*利用`openssl`来查看`CSR`文件：文件包含了我的信息，并标明使用了`sha256`摘要算法和`RSA`公钥加密算法*

```bash
openssl asn1parse -i -in CertificateSigningRequest.certSigningRequest
    0:d=0  hl=4 l= 638 cons: SEQUENCE
    4:d=1  hl=4 l= 358 cons:  SEQUENCE
    8:d=2  hl=2 l=   1 prim:   INTEGER           :00
   11:d=2  hl=2 l=  57 cons:   SEQUENCE
   13:d=3  hl=2 l=  22 cons:    SET
   15:d=4  hl=2 l=  20 cons:     SEQUENCE
   17:d=5  hl=2 l=   9 prim:      OBJECT            :emailAddress
   28:d=5  hl=2 l=   7 prim:      IA5STRING         :xxx.com
   37:d=3  hl=2 l=  18 cons:    SET
   39:d=4  hl=2 l=  16 cons:     SEQUENCE
   41:d=5  hl=2 l=   3 prim:      OBJECT            :commonName
   46:d=5  hl=2 l=   9 prim:      UTF8STRING        :宋XX
   57:d=3  hl=2 l=  11 cons:    SET
   59:d=4  hl=2 l=   9 cons:     SEQUENCE
   61:d=5  hl=2 l=   3 prim:      OBJECT            :countryName
   66:d=5  hl=2 l=   2 prim:      PRINTABLESTRING   :CN
   70:d=2  hl=4 l= 290 cons:   SEQUENCE
   74:d=3  hl=2 l=  13 cons:    SEQUENCE
   76:d=4  hl=2 l=   9 prim:     OBJECT            :rsaEncryption
   87:d=4  hl=2 l=   0 prim:     NULL
   89:d=3  hl=4 l= 271 prim:    BIT STRING
  364:d=2  hl=2 l=   0 cons:   cont [ 0 ]
  366:d=1  hl=2 l=  13 cons:  SEQUENCE
  368:d=2  hl=2 l=   9 prim:   OBJECT            :sha256WithRSAEncryption
  379:d=2  hl=2 l=   0 prim:   NULL
  381:d=1  hl=4 l= 257 prim:  BIT STRING
```

#### 3.3.3、从 Member Center 中申请开发证书

```
1、苹果取出 CertificateSigningRequest.certSigningRequest 中的公钥;
2、然后将我的 Member Center 账号信息和我提交的公钥封装在证书中;
3、并进行数字签名
```

*用`openssl`查看开发证书*

```bash
openssl x509 -inform der -in ios_development.cer -noout -text
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 8261114673414944075 (0x72a56006b5aa354b)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=US, O=Apple Inc., OU=Apple Worldwide Developer Relations, CN=Apple Worldwide Developer Relations Certification Authority
        Validity
            Not Before: Jun 15 06:59:13 2020 GMT
            Not After : Jun 15 06:59:13 2021 GMT
        Subject: UID=H34NZV9396, CN=iPhone Developer: shen dongqu (J4NH894YDN), OU=X8H9B4P8L2, O=ZhongChu NanJing ZhiHuiWuLiu KeJi CO.LTD, C=CN
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:cd:58:f1:21:b2:82:95:e6:7a:4c:72:70:9d:06:
                    12:97:ed:a0:5c:d2:43:e0:f8:96:33:34:ef:a2:62:
                    6e:59:fc:e3:b0:08:5b:0b:9c:d6:4b:37:1e:22:46:
                    32:71:67:b4:ca:14:4a:94:a6:4f:46:b7:b6:f8:bd:
                    e6:8e:f9:f6:a5:0a:9a:24:7f:0d:71:d0:c7:c4:19:
                    be:f9:a4:de:42:1f:22:e2:17:ed:3c:13:00:9c:62:
                    d5:ea:6d:86:9d:6c:6c:90:ae:ea:55:24:f0:00:08:
                    ed:17:cd:d3:cf:40:6d:a7:11:22:c3:cc:24:e0:4a:
                    70:9a:36:8b:ea:f4:e0:42:4c:68:28:69:b0:fa:9b:
                    58:59:ae:58:c3:c2:25:2a:07:ac:c2:ad:53:55:f9:
                    3b:fe:ac:7d:9b:cf:e2:15:ff:c9:e7:eb:ec:27:9a:
                    e3:e9:34:47:d3:1f:68:92:28:14:26:68:0c:13:34:
                    53:ce:a3:03:a8:db:af:2b:3e:2f:45:59:73:6b:42:
                    23:f2:db:81:b3:e4:11:56:3f:2a:db:96:5e:a1:83:
                    32:75:b5:c9:be:1f:bb:9f:49:62:af:63:c8:11:f7:
                    a2:ae:a6:25:2e:69:c5:ff:73:6c:20:da:62:de:0a:
                    27:0d:24:af:da:30:37:ad:d1:7f:97:5a:06:4a:23:
                    fa:53
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Authority Key Identifier:
                keyid:88:27:17:09:A9:B6:18:60:8B:EC:EB:BA:F6:47:59:C5:52:54:A3:B7

            Authority Information Access:
                OCSP - URI:http://ocsp.apple.com/ocsp03-wwdr01

            X509v3 Certificate Policies:
                Policy: 1.2.840.113635.100.5.1
                  User Notice:
                    Explicit Text: Reliance on this certificate by any party assumes acceptance of the then applicable standard terms and conditions of use, certificate policy and certification practice statements.
                  CPS: http://www.apple.com/certificateauthority/

            X509v3 Extended Key Usage: critical
                Code Signing
            X509v3 Subject Key Identifier:
                5C:FF:A1:74:3A:8C:64:9B:38:35:7A:D4:14:53:6E:05:F2:00:1A:55
            X509v3 Key Usage: critical
                Digital Signature
            1.2.840.113635.100.6.1.2: critical
                ..
    Signature Algorithm: sha256WithRSAEncryption
         79:99:29:82:ed:80:3b:5a:6f:f6:5f:53:d0:7b:79:29:0f:46:
         40:a2:e4:c8:3f:f5:c9:09:0b:7a:ec:f9:be:9e:50:6a:fa:83:
         9e:c0:78:74:77:eb:6d:7b:21:df:ca:36:91:79:9a:71:0e:bb:
         a6:41:fb:0a:71:58:b4:b7:b4:f5:00:a0:bb:ca:60:ef:4d:56:
         82:53:ce:38:8d:55:37:ec:65:b1:13:bd:2d:5c:5c:e9:59:65:
         58:d0:c7:bf:be:84:99:31:77:32:80:a2:57:e1:f4:54:46:7e:
         ad:f2:46:fe:6c:ed:d9:9f:e0:50:b8:91:a1:14:e2:48:dd:2f:
         37:80:02:93:db:93:50:27:07:c7:83:ae:b6:5b:4d:ab:dd:41:
         e4:bd:80:21:30:c1:c4:f8:bf:41:f3:e6:0f:5d:6a:39:56:cd:
         0a:d4:ab:27:d3:0f:ae:97:d1:a1:a4:b3:c7:8a:3b:d8:6a:28:
         49:92:76:6f:4c:06:75:96:73:4d:24:bf:50:65:31:80:73:08:
         dd:87:74:6e:b9:9e:e2:0a:0f:25:37:a5:4e:72:4a:e5:c6:93:
         9a:36:8c:ac:a6:1e:1f:74:58:e7:20:5b:1f:e5:31:6c:96:34:
         d8:50:b9:b3:92:72:1a:57:9a:e6:c3:dc:3c:c2:f9:53:27:90:
         2b:2b:60:39
```

```
Data 域即为证书的实际内容，与 Data 域平级的 Signature Algorithm 实际就是苹果的 CA 的公钥，而摘要的签名应该没有显示出来。
Data 域下一级的内容就是我的苹果账号信息，其中最为重要的是我的公钥，这个公钥与我本机的私钥是对应的。
当我们双击安装完证书后，KeyChain 会自动将这对密钥关联起来。

程序跑到真机上的时候就是用这个私钥M给程序包签名的，而公钥M会随着描述文件（.mobileprovision）一起打进App中。
所以，就算你有证书，但是如果没有对应的私钥是没有用的。而团队开发则需要通过 .p12 文件把这个私钥分享给团队其他成员。
```

#### 3.3.4、 iOS授权和描述文件

```
有了证书苹果可以确保 APP 是自己授权的开发者提交的以及 APP 的完整性，但是这样只能确保本 APP 是安全的，并不能细化到 APP 所使用的某些服务是被苹果认可的，不如 APNS 推送，定位等，而且证书也无法限制调试版应用的装机规模，于是苹果推出了 mobileprovision 描述文件。
```

*可以使用命令查看`mobileprovision`*

```bash
security cms -D -I embedded.mobileprovision
```

*`mobileprovision`文件包含*

```
1、每个 APP 必须在 Member Cente r中创建一个对应的Apple ID;
2、不同类型的证书就代表了不同的发布方式，还包括一些功能的能否使用（比如 APN ）;
3、功能授权列表;
4、可安装的设备列表。对于 AdHoc 方式发布的 APP 或者真机调试时，会有一个列表，这个列表里面是 iOS 设备的 UDID，每台 iOS 设备出厂的 UDID 都不同，所以可以用来标识设备。可通过 iTunes 连接设备，或者 http://fir.im/udid 这里获取;
5、苹果的签名：这里的签名是苹果签的，跟我们的私钥没有关系。也就是说 mobileprovision 文件是苹果签名的，我们除了从 Member Center 中获取，别无他法。也不能再获取后随意篡改（比如添加别的设备）。因此上面的1-4就被苹果牢牢的控制在手里，所有的规则都必须由苹果来制定和约束。
```

### 3.4、区块链（BlockChain）

*资料来源*

[Youtube/coinlife2835](https://www.youtube.com/@coinlife2835/videos)

*什么是区块链 ?*

```
1、区块链是互联网的一部分，互联网数据与数据之间的传输方式，数据传输的应用模型; 
    1.1、概念是由中本聪2008年率先提出：《比特币：一个点对点的电子现金系统》
    1.2、相关技术是来自40余年的积累和沉淀;
        1.2.1、1976年，迪菲+赫尔曼 👉🏻 《密码学的新方向》;
        1.2.2、1977年，RSA算法的诞生; 
        1.2.3、1980和1982年，哈希树的数据结构和响应算法+拜占庭将军问题 = 分布式计算的理论进入实质性阶段;
        1.2.4、1985年，椭圆曲线加密算法出世 = 非对称加密体系有了使用的可能;
        就此，现代密码学基础被完全确立
        1.2.5、1997年，智能合约的概念被提出 + 第一代共识机制PoW面世（此时的Pow还仅仅被用于反垃圾邮件）
        自此，区块链4大核心技术基本成型。但是还有一些问题尚未解决;
        1.2.6、1999年（Napster），2000年（EDonkey 2000），2001年（BitTorrent） = 奠定了p2p网络计算的基础;2001年，SHA-2系列算法的诞生
        自此，重大瓶颈问题被解决，区块链的核心技术的积累基本完成。
2、区块链的核心技术 = 密码学 + 分布式储存 + 智能合约 + 共识机制（算法）;
    2.1、智能合约:规则制定好（代码化），由机器自动去执行;（1994年，尼克·萨博提出）
    2.2、密码学应用的部分 = 哈希算法（抗篡改\匿名性\抗碰撞） + 非对称加密;
    2.3、共识机制:每个节点必须遵守的游戏规则。在区块链中起到了协调全账目节点保持一致的作用（如何记账 + 达成共识）;
    	2.3.1、"拜占庭将军问题" = 如果有节点发送了错误的信息，干扰乱网络的正常运行，或者大家产生分歧怎么办？如何取得共识？
    	2.3.2、"拜占庭容错":信息的伪造或者错误并不重要，只要正确的节点数量 > 总数的2/3;
    	2.3.3、当前主流共识机制 = PoW共识机制 + PoS共识机制;
    			在效率、资源消耗 和 安全之中寻求一个平衡点
    	    2.3.3.1、PoW = proof of work = 工作量证明;
    	    最开始应用于解决垃圾邮件，后面发现可以解决"拜占庭将军问题";
    	    主要是通过竞争记账的形式，解决区块链各个节点中的一致性问题;
    	    原理:当一笔交易产生以后，参与记账的节点，需要依靠自己的算力同他节点竞争记账权利;
    	    每隔大约10分钟的时间，进行一次算力竞赛:不断地寻找一个随机数Nonce，谁先找出满足一定条件的Nonce，且广播全网并获得认可;
    	    最终获得认可的节点会获得记账权利，他所打包的区块会记入公链，且同步全网数据节点，且获得一定比特币（BTC）;
    	    理论上，被攻破的可能性在于获得全网大于51%节点的算力，所以加入的人越多，全网算力越强，整个网络越安全;
    	    代价:大量的资源消耗、性能效率低下...
          2.3.3.2、PoS = proof of Stake = 权益证明 = 谁拥有的权益多谁说了算（这有点中心化的意思了，和去中心化的意志相背离）
          2011年开始，主要面向解决PoW的劣势:大量的资源消耗、性能效率低下...
          PoS提高了数据处理的门槛:虽然每个节点都可以加入进来，但是只有满足一定条件的节点（比如质押代币）才有资格成为验证节点（候选人）;
          类似于中国大陆的人民代表大会制度;
          成为候选人以后，系统通过算法，选出一部分作为出块节点。每隔一段时间会重新进行选择。选举过程中算法会保证选举结果不能被操纵和被预测;
          出块节点 = 矿工 = 有资格参与数据处理 = 争夺记账权利 = 有机会获得数字货币
          代价:很可能出现强者恒强的局面。去中心化程度相对于PoW要弱一些;
          理论上，谁能掌握51%及其以上的代币，谁就拥有话语权
3、本质上是一个不可篡改和删除的数据库。在数据上传过程中，数据会被打包到一起，形成一个个的数据库块。打包好的数据块 = 区块，按照时间先后连在一起;
4、特点:去中心化,大家一起记账，你我的账本数据是一致的，也就是即便某个时刻某个节点下线了，没有同步到最新数据，只要他上线，当即拉取同步最新数据;
5、大部分的人(超过51%)的节点认为数据Ok，方可写入区块链这个数据库;(解决信任问题)
6、挖矿:这只是一个形象的比喻，因为和现实生活中的采矿和挖矿有异曲同工之处。在一个时间点，各计算机进行处理同一个数据任务，以先完成任务的为标准。也就是，有些机器可能一辈子有概率只耗电但是挖不出任何的矿;处理好数据的第一名即会获取奖励，即"矿"（数字货币:至少是比特币BTC）。数字货币和区块链这个概念是2008年一同出现的;
7、挖矿原理，实际上是一个数据记录的过程:"矿工"去处理之前没有被确认的交易数据;（共识机制）
8、矿工那么多，到底用谁处理的数据？
    8.1、所有"矿工"在处理（交易）数据的时候，必须加入hash值（文件指纹），争取先完成;
    8.2、并且全网广播确认且大部分（至少超过51%）认为无异议;
    就能获取记录数据的权利 == 获取数字货币（至少是比特币BTC）
9、挖矿的人越多 == 参与确认数据的人越多 == 我们的数据就越安全
10、区块链的分叉:属于区块链的一种独有的版本升级方式。升级的时候需要参与的"矿工" 共同进行确认，可以产生多个版本
    10.1、升级的时候，需要从某一个区块开始，连到两个不同的数据块上面去，从而分成2条链。这个过程叫做分叉;
    10.2、需要达成共识;
    10.3、达成共识以后，老链上的"矿工"逐渐向新链进行过渡，最终只留下新链（软分叉）;
    10.4、不能达成共识的时候，多个版本互不兼容（硬分叉）;
    10.5、区块链的每一个区块，以上一个区块的哈希值作为标识;
11、区块链的分类（按照开放程度）:
    11.1、公有链:去中心化程度最强，偏向公用建设、
    11.2、私有链:去中心化程度很弱，但是因为参与人数少，效率高，偏向企业或者公司方面的建设、
    11.3、联盟链:介于公有链和私有链之间，类似于多个私有链组成的公有链，甚至可以说是多中心化的，偏向企业或者公司方面的建设、
    未来是多链并行的时代
12、"双花问题"其实包含以下2个子问题:
		12.1、一笔钱因为同步延迟的问题，被重复使用;
		12.2、一笔钱虽然只使用了一次，但是黑客攻击或者造假钱等方式，把这笔钱又复制了一次，重复使用;
		现实生活中的解决方案:目前主要通过第三方的机构来解决;
		区块链中的解决方案:共识机制（解决12.1） + 时间戳（解决12.2） + UTXO账户模型;
13、UTXO账户模型 = 未花费交易输出;
		13.1、本质:流水记账。会把交易的过程记录下来（账户资金、交易地址、转账资金、资金来源...）
		13.2、可以追溯交易的资金源头
		13.3、只记录交易本身，而不记录交易结果;
    13.4、业务流程:
		    13.4.1、先通过UTXO账户模型，检验交易资金是否存在;
		    13.4.2、追溯交易的源头，确定没问题后;
		    13.4.3、通过共识机制进行全网广播，写入公链;
14、时间戳:一个字符序列能唯一的标识某个时间;
		14.1、对数据进行哈希运算获得数据指纹;
		14.2、对这个指纹加入时间戳;
		如果要攻破数据 = 攻破哈希指纹 + 时间戳
15、侧链技术 = 链和链之间产生价值交换的技术 = 建立一条新区块链（侧链），能够1对1的和原有的链产生联系，资产可以再两条链之间产生转移（通过双向锚定:一方要以另外一方的行动为标准），进而弥补原来那条链（主链）的不足;
		举例:双向锚定👇🏻
		15.1、当比特币（BTC）想要转移到它的侧链的时候，就会在其主链上对相应数量的比特币（BTC）进行锁定，然后再将等量价值的侧链代币进行释放;
		15.2、当比特币（BTC）想要转回主链的时候，就锁定该数量的侧链代币，释放相应的比特币即可;
		15.3、管理资产的锁定与释放方式 = 第三方机构进行单一托管（单一确认） + 进行联盟托管（多节点确认）
		15.4、解决4大核心技术无法解决问题 = 效率问题 + 可扩展性问题（随着时间的推移，系统的很多功能，没有办法到与之相对应的提升）
				15.4.1、主链上交易处理不过来的时候，转移压力到侧链进行分摊处理
				15.4.2、应用主链的人较多，不方便去做较大改动。那么在侧链进行修改，对主链功能进行补充
16、跨链技术 = 多条链之间产生价值流通的技术 = 侧链的升级版
		16.1、解决互操作性问题:区块链实际应用的时候，因为场景和行业不同以及参与企业不同，导致一个场景都需要一条链甚至多条链，且每条链都比较封闭（信息孤岛）
		16.2、目前4种解决方案:
		    16.2.1、公证技术:瑞波实验室提出一个协议，这个协议适用于各区块链的记账系统，并且能包容相互的差异。大家可以以此作为一个统一的支付标准;
		    16.2.2、中继:类似于侧链（作为中介桥梁 ）。建立一条新链，并使之于其他的链产生联系，其他链可以和这条链产生价值转移。就好像很多链拥有了一条共同的侧链（以此为中介）。OKChain采用这种技术; 
		    16.2.3、分布式私钥控制
		    16.2.4、哈希锁定
		

```

### 3.5、数字货币

*资料来源*

[一文区分传销币，主流币，山寨币，空气币](https://m.163.com/dy/article/GL5CIF8Q0519UA0G.html?spss=adap_pc)

[维基百科/比特币](https://zh.wikipedia.org/wiki/%E6%AF%94%E7%89%B9%E5%B8%81)

[维基百科/泰达币](https://zh.wikipedia.org/wiki/%E6%B3%B0%E8%BE%BE%E5%B8%81)

[维基百科/莱特币](https://zh.wikipedia.org/wiki/%E8%8E%B1%E7%89%B9%E5%B8%81)

[维基百科/狗狗币](https://zh.wikipedia.org/zh-hans/%E7%8B%97%E7%8B%97%E5%B8%81)

[维基百科/数字人民币](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E4%BA%BA%E6%B0%91%E5%B8%81)

[比特币官网](https://bitcoin.org/en/)

[以太坊官网](https://ethereum.org/zh/)

[泰达币官网](https://tether.to/)

[狗狗币官网](https://dogecoin.com/zh-cn/)

#### 3.5.1、概念分类

##### 3.5.1.1、传销币

```
概念：
1、涉及拉人头，拉资金的币，至于是不是数字货币，不好说;
2、早年间的积分盘，本质来说也可称之为传销币，后来五行币，维卡币等基本上属于一类;
特点：
拉人头返利润，宣传高大上，号称创始人无敌，国家扶持等，某些是内盘交易，无法提现到主流平台进行交易。
风险：
1、价格完全项目方控盘，由于拉人头泡沫太大，一旦资金跟不上，崩盘跑路那是挥手间的事;
2、其次，由于币无法提到主流所，可能时刻归零跑路.
```

##### 3.5.1.2、主流币

```
概念：
市面上大多数人认可的加密数字货币。典型的有比特币（BTC）、以太币（ETH）、莱特币、泰达币（USDT）等;
特点：
1、这类币由于起步早，有强大的社区支持者，盘子相对稳定，技术上基本上问题也不大，一般不存在下架跑路风险;
2、但价格波动如果不是受到太大因素影响，一般不会有过大波动;
风险：
最大风险在于换仓，追涨杀跌，合约，由于比较老，因此价格波动不会太大，价格拉升不会太高，因此需要时间才可能有财富。
```

##### 3.5.1.3、山寨币

```
概念：
不等同于假币。山寨意思是模仿，严格意义来说，除了比特币其他都是山寨币;
特点：
由于代码开源，因此市面上山寨币的数量十分多，代码一抄，参数一改，号称最强公链的山寨币就起来了，山寨中做得好的以太坊一样跑出来;
风险：
由于数量过多，故事类似，应用场景差别不大，因此很难选择，但可以选择相对老牌的靠谱
```

##### 3.5.1.4、空气币

```
概念：
指的是没有应用场景的币，严格来说，目前市面上很多都属于空气币;
特点：
代码等抄袭，白皮书等简单，没有落地应用场景;
风险：
1、币价随时归零，共识程度不高，基本上冲着割韭菜而来;
2、不过也有成功案例（波场），不过保守来说，不建议入手;
```

#### 3.5.2、相关代表

*资料来源*

[Github/比特币源代码](https://github.com/bitcoin/bitcoin)

[Github/比特币源码研读](https://github.com/chaors/Bitcoin_read)

[知乎/什么是黑U？散户小白收到黑U怎么办？](https://zhuanlan.zhihu.com/p/565664059?utm_id=0)

[youtube/「比特币入门系列」第23期，trc20和erc20有什么区别？erc20，trc20都是什么链，能相互转账吗？trc20和erc20怎么转账提现？](https://www.youtube.com/watch?v=8spgN7l7GJ0)

[脚本之家-区块链_/USDT提币TRC20和ERC20有什么区别?](https://m.jb51.net/blockchain/784143.html)

##### 3.5.2.1、比特币（BTC）

*MacOS内置的比特币白皮书*

```bash
open /System/Library/Image\ Capture/Devices/VirtualScanner.app/Contents/Resources/simpledoc.pdf
```

```

```

##### 3.5.2.2、泰达币（USDT）

```

```

###### 3.5.2.2.1、黑U

```

```

###### 3.5.2.2.2、`TRC-20 `和`ERC-20`

```

```

##### 3.5.2.3、数字人民币

```

```

#### 3.5.3、交易所

*资料来源*

[维基百科/加密货币交易所](https://zh.m.wikipedia.org/zh-hans/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3%E4%BA%A4%E6%98%93%E6%89%80)

```

```

#### 3.5.4、钱包

*资料来源*

[investglass/热与暖与冷：哪个加密货币钱包适合我？](https://www.investglass.com/zh/hot-vs-warm-vs-cold-which-crypto-wallet-is-right-for-me/)

[欧易官网](https://www.okx.com/cn)

[IMToken官网](https://token.im/)

##### 3.5.4.1、冷钱包

```

```

##### 3.5.4.2、温钱包

```

```

##### 3.5.4.3、热钱包

```

```

#### 3.5.5、发币

*资料来源*

[Youtube/10分钟发行自己的加密货币，零基础教学 | 2021 （ETH， BTC）](https://www.youtube.com/watch?v=x2ZRyloHyG8)

#### 3.5.6、其他

*资料来源*

`defi`

[科普 | 比特币合约是什么？ ](https://www.sohu.com/a/453773508_100217347)









